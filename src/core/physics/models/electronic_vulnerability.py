from dataclasses import dataclass
from enum import Enum
from typing import Dict, List, Optional
import numpy as np

class ElectronicSystemType(Enum):
    COMMUNICATIONS = "communications"
    RADAR = "radar"
    NAVIGATION = "navigation"
    CONTROL_SYSTEMS = "control_systems"
    POWER_SYSTEMS = "power_systems"
    COMPUTING_SYSTEMS = "computing_systems"

@dataclass
class ComponentVulnerability:
    breakdown_voltage: float  # V/m
    susceptibility_frequency: tuple[float, float]  # Hz
    thermal_threshold: float  # W
    recovery_time: float  # s
    shielding_effectiveness: float  # dB

@dataclass
class ElectronicSystem:
    system_type: ElectronicSystemType
    components: Dict[str, ComponentVulnerability]
    physical_dimensions: tuple[float, float, float]  # m
    shielding_type: str
    grounding_resistance: float  # Î©
    operational_frequency: float  # Hz

class EMPVulnerabilityAnalyzer:
    def __init__(self):
        self.thermal_constant = 1.380649e-23  # Boltzmann constant
        self.electron_charge = 1.602176634e-19  # Coulomb
        
    def compute_system_damage(
        self,
        system: ElectronicSystem,
        emp_field: Dict[str, np.ndarray],
        exposure_time: float
    ) -> Dict[str, Any]:
        # Calculate induced voltages and currents
        induced_effects = self._compute_induced_effects(system, emp_field)
        
        # Calculate component damage probabilities
        damage_probs = self._compute_damage_probabilities(
            system.components,
            induced_effects,
            exposure_time
        )
        
        # Calculate system failure modes
        failure_modes = self._analyze_failure_modes(system, damage_probs)
        
        return {
            'induced_effects': induced_effects,
            'component_damage': damage_probs,
            'failure_modes': failure_modes,
            'system_survival_probability': self._compute_survival_probability(damage_probs)
        }
        
    def _compute_induced_effects(
        self,
        system: ElectronicSystem,
        emp_field: Dict[str, np.ndarray]
    ) -> Dict[str, np.ndarray]:
        # Calculate shielding effectiveness
        penetrating_field = self._apply_shielding(
            emp_field,
            system.shielding_type,
            system.physical_dimensions
        )
        
        # Calculate induced voltages using antenna theory
        induced_voltage = self._compute_induced_voltage(
            penetrating_field,
            system.physical_dimensions
        )
        
        # Calculate induced currents using transmission line theory
        induced_current = induced_voltage / system.grounding_resistance
        
        return {
            'voltage': induced_voltage,
            'current': induced_current,
            'power': induced_voltage * induced_current
        }
        
    def _compute_damage_probabilities(
        self,
        components: Dict[str, ComponentVulnerability],
        induced_effects: Dict[str, np.ndarray],
        exposure_time: float
    ) -> Dict[str, float]:
        damage_probs = {}
        
        for component_name, vulnerability in components.items():
            # Calculate voltage stress probability
            voltage_prob = self._compute_voltage_breakdown_probability(
                induced_effects['voltage'],
                vulnerability.breakdown_voltage
            )
            
            # Calculate thermal stress probability
            thermal_prob = self._compute_thermal_damage_probability(
                induced_effects['power'],
                vulnerability.thermal_threshold,
                exposure_time
            )
            
            # Combined probability using worst-case scenario
            damage_probs[component_name] = max(voltage_prob, thermal_prob)
            
        return damage_probs
        
    def _analyze_failure_modes(
        self,
        system: ElectronicSystem,
        damage_probs: Dict[str, float]
    ) -> List[Dict[str, Any]]:
        failure_modes = []
        
        # Analyze cascading failures
        for component, prob in damage_probs.items():
            if prob > 0.5:  # Critical damage threshold
                affected_components = self._identify_dependent_components(
                    system,
                    component
                )
                
                failure_modes.append({
                    'primary_component': component,
                    'failure_probability': prob,
                    'affected_components': affected_components,
                    'system_impact': self._assess_system_impact(
                        system.system_type,
                        component
                    )
                })
                
        return failure_modes
        
    def _compute_survival_probability(
        self,
        damage_probs: Dict[str, float]
    ) -> float:
        # Calculate system survival probability using component dependencies
        return 1.0 - max(damage_probs.values())